/*
 * Permify API
 * Permify is an open source authorization service for creating fine-grained and scalable authorization systems.
 *
 * The version of the OpenAPI document: v1.0.3
 * Contact: hello@permify.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package co.permify.sdk.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import co.permify.sdk.client.ApiClient;
/**
 * A comprehension expression applied to a list or map.  Comprehensions are not part of the core syntax, but enabled with macros. A macro matches a specific call signature within a parsed AST and replaces the call with an alternate AST block. Macro expansion happens at parse time.  The following macros are supported within CEL:  Aggregate type macros may be applied to all elements in a list or all keys in a map:  *  &#x60;all&#x60;, &#x60;exists&#x60;, &#x60;exists_one&#x60; -  test a predicate expression against    the inputs and return &#x60;true&#x60; if the predicate is satisfied for all,    any, or only one value &#x60;list.all(x, x &lt; 10)&#x60;. *  &#x60;filter&#x60; - test a predicate expression against the inputs and return    the subset of elements which satisfy the predicate:    &#x60;payments.filter(p, p &gt; 1000)&#x60;. *  &#x60;map&#x60; - apply an expression to all elements in the input and return the    output aggregate type: &#x60;[1, 2, 3].map(i, i * i)&#x60;.  The &#x60;has(m.x)&#x60; macro tests whether the property &#x60;x&#x60; is present in struct &#x60;m&#x60;. The semantics of this macro depend on the type of &#x60;m&#x60;. For proto2 messages &#x60;has(m.x)&#x60; is defined as &#39;defined, but not set&#x60;. For proto3, the macro tests whether the property is set to its default. For map and struct types, the macro tests whether the property &#x60;x&#x60; is defined on &#x60;m&#x60;.
 */
@JsonPropertyOrder({
  Comprehension.JSON_PROPERTY_ITER_VAR,
  Comprehension.JSON_PROPERTY_ITER_RANGE,
  Comprehension.JSON_PROPERTY_ACCU_VAR,
  Comprehension.JSON_PROPERTY_ACCU_INIT,
  Comprehension.JSON_PROPERTY_LOOP_CONDITION,
  Comprehension.JSON_PROPERTY_LOOP_STEP,
  Comprehension.JSON_PROPERTY_RESULT
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.14.0")
public class Comprehension {
  public static final String JSON_PROPERTY_ITER_VAR = "iterVar";
  @jakarta.annotation.Nullable
  private String iterVar;

  public static final String JSON_PROPERTY_ITER_RANGE = "iterRange";
  @jakarta.annotation.Nullable
  private Object iterRange;

  public static final String JSON_PROPERTY_ACCU_VAR = "accuVar";
  @jakarta.annotation.Nullable
  private String accuVar;

  public static final String JSON_PROPERTY_ACCU_INIT = "accuInit";
  @jakarta.annotation.Nullable
  private Object accuInit;

  public static final String JSON_PROPERTY_LOOP_CONDITION = "loopCondition";
  @jakarta.annotation.Nullable
  private Object loopCondition;

  public static final String JSON_PROPERTY_LOOP_STEP = "loopStep";
  @jakarta.annotation.Nullable
  private Object loopStep;

  public static final String JSON_PROPERTY_RESULT = "result";
  @jakarta.annotation.Nullable
  private Object result;

  public Comprehension() { 
  }

  public Comprehension iterVar(@jakarta.annotation.Nullable String iterVar) {
    this.iterVar = iterVar;
    return this;
  }

  /**
   * The name of the iteration variable.
   * @return iterVar
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ITER_VAR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getIterVar() {
    return iterVar;
  }


  @JsonProperty(JSON_PROPERTY_ITER_VAR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIterVar(@jakarta.annotation.Nullable String iterVar) {
    this.iterVar = iterVar;
  }


  public Comprehension iterRange(@jakarta.annotation.Nullable Object iterRange) {
    this.iterRange = iterRange;
    return this;
  }

  /**
   * An abstract representation of a common expression.  Expressions are abstractly represented as a collection of identifiers, select statements, function calls, literals, and comprehensions. All operators with the exception of the &#39;.&#39; operator are modelled as function calls. This makes it easy to represent new operators into the existing AST.  All references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at type-check for an expression to be valid. A reference may either be a bare identifier &#x60;name&#x60; or a qualified identifier &#x60;google.api.name&#x60;. References may either refer to a value or a function declaration.  For example, the expression &#x60;google.api.name.startsWith(&#39;expr&#39;)&#x60; references the declaration &#x60;google.api.name&#x60; within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and the function declaration &#x60;startsWith&#x60;.
   * @return iterRange
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ITER_RANGE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Object getIterRange() {
    return iterRange;
  }


  @JsonProperty(JSON_PROPERTY_ITER_RANGE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIterRange(@jakarta.annotation.Nullable Object iterRange) {
    this.iterRange = iterRange;
  }


  public Comprehension accuVar(@jakarta.annotation.Nullable String accuVar) {
    this.accuVar = accuVar;
    return this;
  }

  /**
   * The name of the variable used for accumulation of the result.
   * @return accuVar
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACCU_VAR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getAccuVar() {
    return accuVar;
  }


  @JsonProperty(JSON_PROPERTY_ACCU_VAR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAccuVar(@jakarta.annotation.Nullable String accuVar) {
    this.accuVar = accuVar;
  }


  public Comprehension accuInit(@jakarta.annotation.Nullable Object accuInit) {
    this.accuInit = accuInit;
    return this;
  }

  /**
   * An abstract representation of a common expression.  Expressions are abstractly represented as a collection of identifiers, select statements, function calls, literals, and comprehensions. All operators with the exception of the &#39;.&#39; operator are modelled as function calls. This makes it easy to represent new operators into the existing AST.  All references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at type-check for an expression to be valid. A reference may either be a bare identifier &#x60;name&#x60; or a qualified identifier &#x60;google.api.name&#x60;. References may either refer to a value or a function declaration.  For example, the expression &#x60;google.api.name.startsWith(&#39;expr&#39;)&#x60; references the declaration &#x60;google.api.name&#x60; within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and the function declaration &#x60;startsWith&#x60;.
   * @return accuInit
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACCU_INIT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Object getAccuInit() {
    return accuInit;
  }


  @JsonProperty(JSON_PROPERTY_ACCU_INIT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAccuInit(@jakarta.annotation.Nullable Object accuInit) {
    this.accuInit = accuInit;
  }


  public Comprehension loopCondition(@jakarta.annotation.Nullable Object loopCondition) {
    this.loopCondition = loopCondition;
    return this;
  }

  /**
   * An abstract representation of a common expression.  Expressions are abstractly represented as a collection of identifiers, select statements, function calls, literals, and comprehensions. All operators with the exception of the &#39;.&#39; operator are modelled as function calls. This makes it easy to represent new operators into the existing AST.  All references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at type-check for an expression to be valid. A reference may either be a bare identifier &#x60;name&#x60; or a qualified identifier &#x60;google.api.name&#x60;. References may either refer to a value or a function declaration.  For example, the expression &#x60;google.api.name.startsWith(&#39;expr&#39;)&#x60; references the declaration &#x60;google.api.name&#x60; within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and the function declaration &#x60;startsWith&#x60;.
   * @return loopCondition
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LOOP_CONDITION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Object getLoopCondition() {
    return loopCondition;
  }


  @JsonProperty(JSON_PROPERTY_LOOP_CONDITION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLoopCondition(@jakarta.annotation.Nullable Object loopCondition) {
    this.loopCondition = loopCondition;
  }


  public Comprehension loopStep(@jakarta.annotation.Nullable Object loopStep) {
    this.loopStep = loopStep;
    return this;
  }

  /**
   * An abstract representation of a common expression.  Expressions are abstractly represented as a collection of identifiers, select statements, function calls, literals, and comprehensions. All operators with the exception of the &#39;.&#39; operator are modelled as function calls. This makes it easy to represent new operators into the existing AST.  All references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at type-check for an expression to be valid. A reference may either be a bare identifier &#x60;name&#x60; or a qualified identifier &#x60;google.api.name&#x60;. References may either refer to a value or a function declaration.  For example, the expression &#x60;google.api.name.startsWith(&#39;expr&#39;)&#x60; references the declaration &#x60;google.api.name&#x60; within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and the function declaration &#x60;startsWith&#x60;.
   * @return loopStep
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LOOP_STEP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Object getLoopStep() {
    return loopStep;
  }


  @JsonProperty(JSON_PROPERTY_LOOP_STEP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLoopStep(@jakarta.annotation.Nullable Object loopStep) {
    this.loopStep = loopStep;
  }


  public Comprehension result(@jakarta.annotation.Nullable Object result) {
    this.result = result;
    return this;
  }

  /**
   * An abstract representation of a common expression.  Expressions are abstractly represented as a collection of identifiers, select statements, function calls, literals, and comprehensions. All operators with the exception of the &#39;.&#39; operator are modelled as function calls. This makes it easy to represent new operators into the existing AST.  All references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at type-check for an expression to be valid. A reference may either be a bare identifier &#x60;name&#x60; or a qualified identifier &#x60;google.api.name&#x60;. References may either refer to a value or a function declaration.  For example, the expression &#x60;google.api.name.startsWith(&#39;expr&#39;)&#x60; references the declaration &#x60;google.api.name&#x60; within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and the function declaration &#x60;startsWith&#x60;.
   * @return result
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RESULT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Object getResult() {
    return result;
  }


  @JsonProperty(JSON_PROPERTY_RESULT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setResult(@jakarta.annotation.Nullable Object result) {
    this.result = result;
  }


  /**
   * Return true if this Comprehension object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Comprehension comprehension = (Comprehension) o;
    return Objects.equals(this.iterVar, comprehension.iterVar) &&
        Objects.equals(this.iterRange, comprehension.iterRange) &&
        Objects.equals(this.accuVar, comprehension.accuVar) &&
        Objects.equals(this.accuInit, comprehension.accuInit) &&
        Objects.equals(this.loopCondition, comprehension.loopCondition) &&
        Objects.equals(this.loopStep, comprehension.loopStep) &&
        Objects.equals(this.result, comprehension.result);
  }

  @Override
  public int hashCode() {
    return Objects.hash(iterVar, iterRange, accuVar, accuInit, loopCondition, loopStep, result);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Comprehension {\n");
    sb.append("    iterVar: ").append(toIndentedString(iterVar)).append("\n");
    sb.append("    iterRange: ").append(toIndentedString(iterRange)).append("\n");
    sb.append("    accuVar: ").append(toIndentedString(accuVar)).append("\n");
    sb.append("    accuInit: ").append(toIndentedString(accuInit)).append("\n");
    sb.append("    loopCondition: ").append(toIndentedString(loopCondition)).append("\n");
    sb.append("    loopStep: ").append(toIndentedString(loopStep)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `iterVar` to the URL query string
    if (getIterVar() != null) {
      joiner.add(String.format("%siterVar%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getIterVar()))));
    }

    // add `iterRange` to the URL query string
    if (getIterRange() != null) {
      joiner.add(String.format("%siterRange%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getIterRange()))));
    }

    // add `accuVar` to the URL query string
    if (getAccuVar() != null) {
      joiner.add(String.format("%saccuVar%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getAccuVar()))));
    }

    // add `accuInit` to the URL query string
    if (getAccuInit() != null) {
      joiner.add(String.format("%saccuInit%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getAccuInit()))));
    }

    // add `loopCondition` to the URL query string
    if (getLoopCondition() != null) {
      joiner.add(String.format("%sloopCondition%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getLoopCondition()))));
    }

    // add `loopStep` to the URL query string
    if (getLoopStep() != null) {
      joiner.add(String.format("%sloopStep%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getLoopStep()))));
    }

    // add `result` to the URL query string
    if (getResult() != null) {
      joiner.add(String.format("%sresult%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getResult()))));
    }

    return joiner.toString();
  }
}

