/*
 * Permify API
 * Permify is an open source authorization service for creating fine-grained and scalable authorization systems.
 *
 * The version of the OpenAPI document: v0.9.9
 * Contact: hello@permify.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.permify.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import org.permify.model.Expr;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * A comprehension expression applied to a list or map.  Comprehensions are not part of the core syntax, but enabled with macros. A macro matches a specific call signature within a parsed AST and replaces the call with an alternate AST block. Macro expansion happens at parse time.  The following macros are supported within CEL:  Aggregate type macros may be applied to all elements in a list or all keys in a map:  *  &#x60;all&#x60;, &#x60;exists&#x60;, &#x60;exists_one&#x60; -  test a predicate expression against    the inputs and return &#x60;true&#x60; if the predicate is satisfied for all,    any, or only one value &#x60;list.all(x, x &lt; 10)&#x60;. *  &#x60;filter&#x60; - test a predicate expression against the inputs and return    the subset of elements which satisfy the predicate:    &#x60;payments.filter(p, p &gt; 1000)&#x60;. *  &#x60;map&#x60; - apply an expression to all elements in the input and return the    output aggregate type: &#x60;[1, 2, 3].map(i, i * i)&#x60;.  The &#x60;has(m.x)&#x60; macro tests whether the property &#x60;x&#x60; is present in struct &#x60;m&#x60;. The semantics of this macro depend on the type of &#x60;m&#x60;. For proto2 messages &#x60;has(m.x)&#x60; is defined as &#39;defined, but not set&#x60;. For proto3, the macro tests whether the property is set to its default. For map and struct types, the macro tests whether the property &#x60;x&#x60; is defined on &#x60;m&#x60;.
 */
@JsonPropertyOrder({
  Comprehension.JSON_PROPERTY_ITER_VAR,
  Comprehension.JSON_PROPERTY_ITER_RANGE,
  Comprehension.JSON_PROPERTY_ACCU_VAR,
  Comprehension.JSON_PROPERTY_ACCU_INIT,
  Comprehension.JSON_PROPERTY_LOOP_CONDITION,
  Comprehension.JSON_PROPERTY_LOOP_STEP,
  Comprehension.JSON_PROPERTY_RESULT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-07-19T12:59:35.606772+03:00[Europe/Istanbul]", comments = "Generator version: 7.7.0")
public class Comprehension {
  public static final String JSON_PROPERTY_ITER_VAR = "iterVar";
  private String iterVar;

  public static final String JSON_PROPERTY_ITER_RANGE = "iterRange";
  private Expr iterRange;

  public static final String JSON_PROPERTY_ACCU_VAR = "accuVar";
  private String accuVar;

  public static final String JSON_PROPERTY_ACCU_INIT = "accuInit";
  private Expr accuInit;

  public static final String JSON_PROPERTY_LOOP_CONDITION = "loopCondition";
  private Expr loopCondition;

  public static final String JSON_PROPERTY_LOOP_STEP = "loopStep";
  private Expr loopStep;

  public static final String JSON_PROPERTY_RESULT = "result";
  private Expr result;

  public Comprehension() {
  }

  public Comprehension iterVar(String iterVar) {
    
    this.iterVar = iterVar;
    return this;
  }

  /**
   * The name of the iteration variable.
   * @return iterVar
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ITER_VAR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getIterVar() {
    return iterVar;
  }


  @JsonProperty(JSON_PROPERTY_ITER_VAR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIterVar(String iterVar) {
    this.iterVar = iterVar;
  }

  public Comprehension iterRange(Expr iterRange) {
    
    this.iterRange = iterRange;
    return this;
  }

  /**
   * Get iterRange
   * @return iterRange
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ITER_RANGE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Expr getIterRange() {
    return iterRange;
  }


  @JsonProperty(JSON_PROPERTY_ITER_RANGE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIterRange(Expr iterRange) {
    this.iterRange = iterRange;
  }

  public Comprehension accuVar(String accuVar) {
    
    this.accuVar = accuVar;
    return this;
  }

  /**
   * The name of the variable used for accumulation of the result.
   * @return accuVar
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACCU_VAR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getAccuVar() {
    return accuVar;
  }


  @JsonProperty(JSON_PROPERTY_ACCU_VAR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAccuVar(String accuVar) {
    this.accuVar = accuVar;
  }

  public Comprehension accuInit(Expr accuInit) {
    
    this.accuInit = accuInit;
    return this;
  }

  /**
   * Get accuInit
   * @return accuInit
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACCU_INIT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Expr getAccuInit() {
    return accuInit;
  }


  @JsonProperty(JSON_PROPERTY_ACCU_INIT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAccuInit(Expr accuInit) {
    this.accuInit = accuInit;
  }

  public Comprehension loopCondition(Expr loopCondition) {
    
    this.loopCondition = loopCondition;
    return this;
  }

  /**
   * Get loopCondition
   * @return loopCondition
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LOOP_CONDITION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Expr getLoopCondition() {
    return loopCondition;
  }


  @JsonProperty(JSON_PROPERTY_LOOP_CONDITION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLoopCondition(Expr loopCondition) {
    this.loopCondition = loopCondition;
  }

  public Comprehension loopStep(Expr loopStep) {
    
    this.loopStep = loopStep;
    return this;
  }

  /**
   * Get loopStep
   * @return loopStep
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LOOP_STEP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Expr getLoopStep() {
    return loopStep;
  }


  @JsonProperty(JSON_PROPERTY_LOOP_STEP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLoopStep(Expr loopStep) {
    this.loopStep = loopStep;
  }

  public Comprehension result(Expr result) {
    
    this.result = result;
    return this;
  }

  /**
   * Get result
   * @return result
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RESULT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Expr getResult() {
    return result;
  }


  @JsonProperty(JSON_PROPERTY_RESULT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setResult(Expr result) {
    this.result = result;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Comprehension comprehension = (Comprehension) o;
    return Objects.equals(this.iterVar, comprehension.iterVar) &&
        Objects.equals(this.iterRange, comprehension.iterRange) &&
        Objects.equals(this.accuVar, comprehension.accuVar) &&
        Objects.equals(this.accuInit, comprehension.accuInit) &&
        Objects.equals(this.loopCondition, comprehension.loopCondition) &&
        Objects.equals(this.loopStep, comprehension.loopStep) &&
        Objects.equals(this.result, comprehension.result);
  }

  @Override
  public int hashCode() {
    return Objects.hash(iterVar, iterRange, accuVar, accuInit, loopCondition, loopStep, result);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Comprehension {\n");
    sb.append("    iterVar: ").append(toIndentedString(iterVar)).append("\n");
    sb.append("    iterRange: ").append(toIndentedString(iterRange)).append("\n");
    sb.append("    accuVar: ").append(toIndentedString(accuVar)).append("\n");
    sb.append("    accuInit: ").append(toIndentedString(accuInit)).append("\n");
    sb.append("    loopCondition: ").append(toIndentedString(loopCondition)).append("\n");
    sb.append("    loopStep: ").append(toIndentedString(loopStep)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

